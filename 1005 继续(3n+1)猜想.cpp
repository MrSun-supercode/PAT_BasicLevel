///*
//卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。
//
//当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。例如对 n=3 进行验证的时候，我们需要计算 3、5、8、4、2、1，则当我们对 n=5、8、4、2 进行验证的时候，就可以直接判定卡拉兹猜想的真伪，而不需要重复计算，因为这 4 个数已经在验证3的时候遇到过了，我们称 5、8、4、2 是被 3“覆盖”的数。我们称一个数列中的某个数 n 为“关键数”，如果 n 不能被数列中的其他数字所覆盖。
//
//现在给定一系列待验证的数字，我们只需要验证其中的几个关键数，就可以不必再重复验证余下的数字。你的任务就是找出这些关键数字，并按从大到小的顺序输出它们。
//
//输入格式：
//每个测试输入包含 1 个测试用例，第 1 行给出一个正整数 K (<100)，第 2 行给出 K 个互不相同的待验证的正整数 n (1<n≤100)的值，数字间用空格隔开。
//
//输出格式：
//每个测试用例的输出占一行，按从大到小的顺序输出关键数字。数字间用 1 个空格隔开，但一行中最后一个数字后没有空格。
//
//输入样例：
//6
//3 5 6 7 8 11
//输出样例：
//7 6
//*/
///*
//
//将所有出现过的数字对应的索引在临时数组中变为1
//*/
//#include<iostream>
//#include<vector>
//#include<algorithm>
//using namespace std;
//bool cmp(int a, int b)//排序函数
//{
//	return a>b;
//}
//int main(void)
//{
//	int n;
//	cin >> n;
//	int a[100];
//	vector <int> V;
//	int mark[100] = { 0 };//临时数组
//		for (int i = 0; i < n; i++)
//		{
//			cin >> a[i];
//		}
//	for (int i = 0; i < n; i++)
//	{
//		/*cin >> a[i];*/
//		int tmp = a[i];
//		while (tmp != 1)
//		{
//			if (tmp % 2 == 0)
//			{
//				tmp /= 2;
//			}
//			else {																		
//				tmp = (3 * tmp + 1) / 2;
//			}
//			if (tmp<101)
//			{
//				mark[tmp] = 1;
//			}
//		}			
//	}
//	for (int i = 0; i < n; i++)//遍历临时数组，如果存在0的元素，说明数组当前索引没有出现过，将该数放入vector中
//	{
//		if (mark[a[i]] == 0)
//		{
//			V.push_back(a[i]);
//		}
//	}
//	sort(V.begin(), V.end(), cmp);
//	for (int i = 0; i < V.size(); ++i)//最后输出时，最后一个元素后面不光不要有空格，还要有换行符
//	{
//		if (i != V.size() - 1)
//			cout << V[i] << ' ';
//		else
//			cout << V[i] << endl;
//	}
//	system("pause");
//	return 0;
//}